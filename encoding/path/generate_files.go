package path

import (
	"go/ast"
	"go/parser"
	"go/token"
	"os"
	"os/exec"
	"path/filepath"
	"text/template"

	"github.com/thatguystone/cog/cfs"
)

//gocovr:skip-file

type generateFile string

const commentHead = `// DO NOT EDIT.
//
// File autogenerated by cog-path.
`

const tmpComment = commentHead + `//
// This file typically deletes itself after being run with 'go run'. If it gets
// left behind, it's safe to delete.
`

var mainTmpl = template.Must(template.New("main").Parse(tmpComment + `
package main

import (
	"fmt"
	"os"

	"github.com/thatguystone/cog/encoding/path"
	pkg "{{.Import}}"
)

func main() {
	os.Remove("{{.AbsPath}}")

	err := path.GenerateFromTypes(
		"{{.GenPath}}",
		"{{.Pkg}}",
		pkg.ExposedCogPaths()...)
	if err != nil {
		fmt.Printf("Failed to generate {{.GenPath}}: %v\n", err)
	}
}
`))

var exposeTmpl = template.Must(template.New("expose").Parse(tmpComment + `
package {{.Pkg}}

import (
	"os"
)

func ExposedCogPaths() []interface{} {
	os.Remove("{{.AbsPath}}")

	return []interface{}{
		{{range .Types}}
			new({{.}}),
		{{end}}
	}
}
`))

func GenerateFromFile(path string) error {
	f := generateFile(path)

	expPkg, expAbsPath, err := f.createExpose()
	defer os.Remove(expAbsPath)

	if err == nil {
		var mainPath string
		mainPath, err = f.execMain(expPkg, expAbsPath)
		defer os.Remove(mainPath)
	}

	return err
}

func (f generateFile) createExpose() (expPkg, expAbsPath string, err error) {
	fset := token.NewFileSet()
	fAst, err := parser.ParseFile(fset, string(f), nil, 0)
	if err != nil {
		return
	}

	exposeDir := filepath.Dir(string(f))
	expose, err := cfs.TempFileIn(exposeDir, "cog_path_gen_", ".go")
	if err != nil {
		return
	}

	defer expose.Close()

	expAbsPath, err = filepath.Abs(expose.Name())
	if err != nil {
		return
	}

	var types []string
	ast.Inspect(fAst, func(n ast.Node) bool {
		ts, ok := n.(*ast.TypeSpec)
		if !ok {
			return true
		}

		types = append(types, ts.Name.String())
		return false
	})

	expPkg = fAst.Name.Name
	err = exposeTmpl.Execute(expose, map[string]interface{}{
		"AbsPath": expAbsPath,
		"Pkg":     expPkg,
		"Types":   types,
	})

	if err != nil {
		return
	}

	return
}

func (f generateFile) execMain(expPkg, expAbsPath string) (
	mainAbsPath string,
	err error) {

	main, err := cfs.TempFile("cog_path_gen_", ".go")
	if err != nil {
		return
	}

	defer main.Close()
	mainAbsPath = main.Name()

	imp, err := cfs.ImportPath(expAbsPath)
	if err != nil {
		return
	}

	genDir := filepath.Dir(expAbsPath)
	genFile := cfs.DropExt(filepath.Base(string(f))) + "_cog_path.go"

	err = mainTmpl.Execute(main, map[string]interface{}{
		"AbsPath": mainAbsPath,
		"GenPath": filepath.Join(genDir, genFile),
		"Import":  imp,
		"Pkg":     expPkg,
	})

	main.Close()

	cmd := exec.Command("go", "run", mainAbsPath)
	cmd.Stdout = os.Stdout
	cmd.Stderr = os.Stderr
	err = cmd.Run()

	return
}
